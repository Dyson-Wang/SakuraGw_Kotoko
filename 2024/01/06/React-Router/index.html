<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>React-Router | 樱川琴子的 备忘录</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="React-RouterReact Router 中有三种类型的组件： router components, route matching components，和 navigation components。 React-router-domrouter components&lt;Router&gt;Router 是所有路由组件共用的底层接口。通常，我们的应用程序将使用其中一个高级路由器代替：">
<meta property="og:type" content="article">
<meta property="og:title" content="React-Router">
<meta property="og:url" content="https://dyson-wang.github.io/SakuraGw_Kotoko/2024/01/06/React-Router/index.html">
<meta property="og:site_name" content="樱川琴子的 备忘录">
<meta property="og:description" content="React-RouterReact Router 中有三种类型的组件： router components, route matching components，和 navigation components。 React-router-domrouter components&lt;Router&gt;Router 是所有路由组件共用的底层接口。通常，我们的应用程序将使用其中一个高级路由器代替：">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-01-06T04:02:53.798Z">
<meta property="article:modified_time" content="2022-09-10T19:58:54.000Z">
<meta property="article:author" content="Dyson Wang">
<meta property="article:tag" content="Blogs Articles">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/SakuraGw_Kotoko/atom.xml" title="樱川琴子的 备忘录" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/SakuraGw_Kotoko/favicon.png">
  
  
  
<link rel="stylesheet" href="/SakuraGw_Kotoko/css/style.css">

  
    
<link rel="stylesheet" href="/SakuraGw_Kotoko/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/SakuraGw_Kotoko/" id="logo">樱川琴子的 备忘录</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/SakuraGw_Kotoko/" id="subtitle">这是一个副标题</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/SakuraGw_Kotoko/">Home</a>
        
          <a class="main-nav-link" href="/SakuraGw_Kotoko/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/SakuraGw_Kotoko/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://dyson-wang.github.io/SakuraGw_Kotoko"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-React-Router" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/SakuraGw_Kotoko/2024/01/06/React-Router/" class="article-date">
  <time class="dt-published" datetime="2024-01-06T04:02:53.798Z" itemprop="datePublished">2024-01-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      React-Router
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="React-Router"><a href="#React-Router" class="headerlink" title="React-Router"></a>React-Router</h1><p>React Router 中有三种类型的组件： router components, route matching components，和 navigation components。</p>
<h2 id="React-router-dom"><a href="#React-router-dom" class="headerlink" title="React-router-dom"></a>React-router-dom</h2><h3 id="router-components"><a href="#router-components" class="headerlink" title="router components"></a>router components</h3><h4 id=""><a href="#" class="headerlink" title="&lt;Router&gt;"></a><code>&lt;Router&gt;</code></h4><p>Router 是所有路由组件共用的底层接口。通常，我们的应用程序将使用其中一个高级路由器代替：</p>
<ul>
<li><code>&lt;BrowserRouter&gt;</code></li>
<li><code>&lt;HashRouter&gt;</code></li>
<li><code>&lt;MemoryRouter&gt;</code></li>
<li><code>&lt;NativeRouter&gt;</code></li>
<li><code>&lt;StaticRouter&gt;</code></li>
</ul>
<p>最常见的使用底层的 <Router> 的情形就是用来与 Redux 或者 Mobx 之类的状态管理库的定制的 history 保持同步。注意不是说使用状态管理库就必须使用 React Router ，它仅用作于深度集成。</p>
<h4 id="-1"><a href="#-1" class="headerlink" title="&lt;BrowserRouter&gt;"></a><code>&lt;BrowserRouter&gt;</code></h4><h4 id="-2"><a href="#-2" class="headerlink" title="&lt;HashRouter&gt;"></a><code>&lt;HashRouter&gt;</code></h4><h4 id="-3"><a href="#-3" class="headerlink" title="&lt;MemoryRouter&gt;"></a><code>&lt;MemoryRouter&gt;</code></h4><h4 id="-4"><a href="#-4" class="headerlink" title="&lt;NativeRouter&gt;"></a><code>&lt;NativeRouter&gt;</code></h4><h4 id="-5"><a href="#-5" class="headerlink" title="&lt;StaticRouter&gt;"></a><code>&lt;StaticRouter&gt;</code></h4><h3 id="route-matching-components"><a href="#route-matching-components" class="headerlink" title="route matching components"></a>route matching components</h3><h4 id="Route"><a href="#Route" class="headerlink" title="Route"></a><code>Route</code></h4><p>没有路径总会匹配挂载，如果不需要请用<code>Switch</code></p>
<p>以下所有的三种渲染方法都会通过三个相同的Route属性</p>
<ul>
<li>match</li>
<li>location</li>
<li>history</li>
</ul>
<hr>
<p><strong>history</strong></p>
<p>本文档中的 “history” 以及 “history对象”指的是 history 包中的内容，该包是 React Router 仅有的两大主要依赖之一（除去 React 本身），在不同的 Javascript 环境中，它提供多种不同的形式来实现对 session 历史的管理。</p>
<p>history 对象通常会具有以下属性和方法：</p>
<ul>
<li>length (number 类型) history 堆栈的条目数</li>
<li>action (string 类型) 当前的操作(PUSH, REPLACE, POP)</li>
<li>location (object 类型) 当前的位置。location 会具有以下属性：<ul>
<li>pathname (string 类型) URL 路径</li>
<li>search (string 类型) URL 中的查询字符串</li>
<li>hash (string 类型) URL 的哈希片段</li>
<li>state (object 类型) 提供给例如使用 push(path, state) 操作将 location 放入堆栈时的特定 location 状态。只在浏览器和内存历史中可用。</li>
</ul>
</li>
<li>push(path, [state]) 在 history 堆栈添加一个新条目</li>
<li>replace(path, [state]) 替换在 history 堆栈中的当前条目</li>
<li>go(n) 将 history 堆栈中的指针调整 n</li>
<li>goBack() 等同于 go(-1)</li>
<li>goForward() 等同于 go(1)</li>
<li>block(prompt) 阻止跳转。(详见 history 文档)。</li>
</ul>
<p>history 是可变的，因此我们建议从 <code>&lt;Route&gt;</code> 的渲染选项中来访问 location，而不是从 history.location 直接获取。这样做可以保证 React 在生命周期中的钩子函数正常执行，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Comp extends React.Component &#123;</span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    // locationChanged 将为 true</span><br><span class="line">    const locationChanged = nextProps.location !== this.props.location</span><br><span class="line"></span><br><span class="line">    // INCORRECT，因为 history 是可变的所以 locationChanged 将一直为 false</span><br><span class="line">    const locationChanged = nextProps.history.location !== this.props.history.location</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;Route component=&#123;Comp&#125;/&gt;</span><br></pre></td></tr></table></figure>

<p><strong>location</strong></p>
<p>location 代表应用程序现在在哪，你想让它去哪，或者甚至它曾经在哪，它看起来就像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  key: &#x27;ac3df4&#x27;, // not with HashHistory!</span><br><span class="line">  pathname: &#x27;/somewhere&#x27;</span><br><span class="line">  search: &#x27;?some=search-string&#x27;,</span><br><span class="line">  hash: &#x27;#howdy&#x27;,</span><br><span class="line">  state: &#123;</span><br><span class="line">    [userDefined]: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>router 将在这几个地方为您提供一个 location 对象：</p>
<ul>
<li>Route component as this.props.location</li>
<li>Route render as ({ location }) &#x3D;&gt; ()</li>
<li>Route children as ({ location }) &#x3D;&gt; ()</li>
<li>withRouter as this.props.location</li>
</ul>
<p><em>它也可以在 history.location 找到，但是你不应该使用它，因为它是可变的，你可以在 history 文档中阅读更多内容。</em></p>
<p>location 对象永远不会发生变化，因此你可以在生命周期钩子中使用它来确定何时导航，这对数据抓取和动画非常有用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">  if (nextProps.location !== this.props.location) &#123;</span><br><span class="line">    // navigated!</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以将 location 而不是字符串提供给导航的各种位置：</p>
<ul>
<li>Web Link to</li>
<li>Native Link to</li>
<li>Redirect to</li>
<li>history.push</li>
<li>history.replace</li>
</ul>
<p>通常你只是使用一个字符串，但是如果你需要添加一些 “location state”，只要应用程序返回到特定的地址就可以使用，你可以使用 location 对象。 如果你想根据导航历史记录而不是仅路径（比如模式）来分支UI，这很有用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// usually all you need</span><br><span class="line">&lt;Link to=&quot;/somewhere&quot;/&gt;</span><br><span class="line"></span><br><span class="line">// but you can use a location instead</span><br><span class="line">const location = &#123;</span><br><span class="line">  pathname: &#x27;/somewhere&#x27;,</span><br><span class="line">  state: &#123; fromDashboard: true &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;Link to=&#123;location&#125;/&gt;</span><br><span class="line">&lt;Redirect to=&#123;location&#125;/&gt;</span><br><span class="line">history.push(location)</span><br><span class="line">history.replace(location)</span><br></pre></td></tr></table></figure>

<p>最后，你可以将 location 传递给以下组件：</p>
<ul>
<li>Route</li>
<li>Switch</li>
</ul>
<p>这将阻止他们在 router 的状态下使用实际的 location。这对动画和在等待的导航非常有用，或者任何时候你想哄骗一个组件在不同的 location 渲染到真实的位置。</p>
<p><strong>match</strong></p>
<p>一个 match 对象中包涵了有关如何匹配 URL 的信息。match 对象中包涵以下属性：</p>
<ul>
<li>params - (object) key／value 与动态路径的 URL 对应解析</li>
<li>isExact - (boolean) true 如果匹配整个 URL （没有结尾字符）</li>
<li>path - (string) 用于匹配的路径模式。被嵌套在 <code>&lt;Route&gt;</code> 中使用</li>
<li>url - (string) 用于匹配部分的 URL 。被嵌套在 <code>&lt;Link&gt;</code> 中使用</li>
</ul>
<p>你将会在这些地方用到 match 对象：</p>
<ul>
<li>Route component 例如 this.props.match</li>
<li>Route render 例如 ({ match }) &#x3D;&gt; ()</li>
<li>Route children 例如 ({ match }) &#x3D;&gt; ()</li>
<li>withRouter 例如 this.props.match</li>
<li>matchPath 例如 返回值</li>
</ul>
<p>如果 Route 没有 path，那么将会一直与他最近的父级匹配。这也同样适用于withRouter。</p>
<p><em>null matches</em></p>
<p>当前路由的 path 与当前地址不匹配时，使用 children 属性的 <code>&lt;Route&gt;</code> 将调用 children 方法。这种情况下， match 将为 null 。当 <code>&lt;Route&gt;</code> 中的内容能够被渲染出来时，说明匹配成功，但这种情况是有挑战性的。</p>
<p>“解析”URL的默认方式是将 match.url 字符串连接到“相对”路径。</p>
<p><code>$&#123;match.url&#125;/relative-path</code></p>
<p>如果你的匹配为 null 时尝试执行此操作，则会出现TypeError。它的意思是在使用子级属性时在 <code>&lt;Route&gt;</code> 内部加入“相对”路径是不安全的。</p>
<p>当您在生成null匹配对象的 <code>&lt;Route&gt;</code> 内部使用无路径的 <code>&lt;Route&gt;</code> 时。会出现类似但更微妙的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// location.pathname = &#x27;/matches&#x27;</span><br><span class="line">&lt;Route path=&#x27;/does-not-match&#x27; children=&#123;(&#123; match &#125;) =&gt; (</span><br><span class="line">  // match === null</span><br><span class="line">  &lt;Route render=&#123;(&#123; match:pathlessMatch &#125;) =&gt; (</span><br><span class="line">    // pathlessMatch === ???</span><br><span class="line">  )&#125;/&gt;</span><br><span class="line">)&#125;/&gt;</span><br></pre></td></tr></table></figure>

<p>无路径的 <Route> 从它们的父节点继承它们的match对象。 如果他们的父match是null，那么他们的匹配也是null。 这意味着：a）任何子路由&#x2F;链接必须是绝对的，因为没有父级去解决，并且b）父级路径match可以是null的无路径路由将需要使用子级属性进行渲染。</p>
<hr>
<h5 id="component-props"><a href="#component-props" class="headerlink" title="component props"></a>component props</h5><p>参数是一个组件</p>
<h5 id="render-props"><a href="#render-props" class="headerlink" title="render props"></a>render props</h5><p>参数是一个函数 <code>props =&gt; &lt;Component &#123;...props&#125; extra=&#123;someVariable&#125; /&gt;</code></p>
<h5 id="children-props"><a href="#children-props" class="headerlink" title="children props"></a>children props</h5><h4 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a><code>Switch</code></h4><p>返回第一个匹配的路由</p>
<h3 id="navigation-components"><a href="#navigation-components" class="headerlink" title="navigation components"></a>navigation components</h3><h4 id="Link"><a href="#Link" class="headerlink" title="Link"></a><code>Link</code></h4><p>React Router 提供了一个 <code>&lt;Link&gt;</code> 组件来在你的应用程序中创建链接。无论你在何处渲染一个 <code>&lt;Link&gt;</code> ，都会在应用程序的 HTML 中渲染锚 （<code>&lt;a&gt;</code>）。</p>
<h4 id="NavLink"><a href="#NavLink" class="headerlink" title="NavLink"></a><code>NavLink</code></h4><p><code>&lt;NavLink&gt;</code> 是一种特殊类型的 <code>&lt;Link&gt;</code> 当它的 to 属性与当前地址匹配时，可以将其定义为“活跃的”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// location = &#123; pathname: &#x27;/react&#x27; &#125;</span><br><span class="line">&lt;NavLink to=&quot;/react&quot; activeClassName=&quot;hurray&quot;&gt;</span><br><span class="line">  React</span><br><span class="line">&lt;/NavLink&gt;</span><br><span class="line">// &lt;a href=&#x27;/react&#x27; className=&#x27;hurray&#x27;&gt;React&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Redirect"><a href="#Redirect" class="headerlink" title="Redirect"></a><code>Redirect</code></h4><p>当你想强制导航时，你可以渲染一个 <code>&lt;Redirect&gt;</code>。当一个 <code>&lt;Redirect&gt;</code> 渲染时，它将使用它的 to 属性进行定向。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://dyson-wang.github.io/SakuraGw_Kotoko/2024/01/06/React-Router/" data-id="clr1k5drt0013pcvnga470h51" data-title="React-Router" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/SakuraGw_Kotoko/tags/Blogs-Articles/" rel="tag">Blogs Articles</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/SakuraGw_Kotoko/2024/01/06/Redux%20Notes/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          Redux Notes
        
      </div>
    </a>
  
  
    <a href="/SakuraGw_Kotoko/2024/01/06/React%20Notes/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">React Notes</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/SakuraGw_Kotoko/tags/Blogs-Articles/" rel="tag">Blogs Articles</a></li><li class="tag-list-item"><a class="tag-list-link" href="/SakuraGw_Kotoko/tags/Private/" rel="tag">Private</a></li><li class="tag-list-item"><a class="tag-list-link" href="/SakuraGw_Kotoko/tags/Programming-Language/" rel="tag">Programming Language</a></li><li class="tag-list-item"><a class="tag-list-link" href="/SakuraGw_Kotoko/tags/%E6%95%99%E7%A8%8B/" rel="tag">教程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/SakuraGw_Kotoko/tags/%E6%96%87%E7%8C%AE/" rel="tag">文献</a></li><li class="tag-list-item"><a class="tag-list-link" href="/SakuraGw_Kotoko/tags/%E8%B4%A6%E5%8F%B7/" rel="tag">账号</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/SakuraGw_Kotoko/tags/Blogs-Articles/" style="font-size: 20px;">Blogs Articles</a> <a href="/SakuraGw_Kotoko/tags/Private/" style="font-size: 16.67px;">Private</a> <a href="/SakuraGw_Kotoko/tags/Programming-Language/" style="font-size: 13.33px;">Programming Language</a> <a href="/SakuraGw_Kotoko/tags/%E6%95%99%E7%A8%8B/" style="font-size: 10px;">教程</a> <a href="/SakuraGw_Kotoko/tags/%E6%96%87%E7%8C%AE/" style="font-size: 10px;">文献</a> <a href="/SakuraGw_Kotoko/tags/%E8%B4%A6%E5%8F%B7/" style="font-size: 10px;">账号</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/SakuraGw_Kotoko/archives/2024/01/">一月 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/SakuraGw_Kotoko/2024/01/06/%E5%B7%B2%E9%98%85%E8%AF%BB%E6%96%87%E7%8C%AE/">已阅读文献</a>
          </li>
        
          <li>
            <a href="/SakuraGw_Kotoko/2024/01/06/%E4%B8%89%E6%9C%88%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2/">三月学习大纲</a>
          </li>
        
          <li>
            <a href="/SakuraGw_Kotoko/2024/01/06/Web%20Docs/">Web Docs</a>
          </li>
        
          <li>
            <a href="/SakuraGw_Kotoko/2024/01/06/TO-DO%20Items/">TO-DO Items</a>
          </li>
        
          <li>
            <a href="/SakuraGw_Kotoko/2024/01/06/Serverless%20in%20linux/">Serverless in linux</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Dyson Wang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/SakuraGw_Kotoko/" class="mobile-nav-link">Home</a>
  
    <a href="/SakuraGw_Kotoko/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/SakuraGw_Kotoko/js/jquery-3.6.4.min.js"></script>



  
<script src="/SakuraGw_Kotoko/fancybox/jquery.fancybox.min.js"></script>




<script src="/SakuraGw_Kotoko/js/script.js"></script>





  </div>
</body>
</html>